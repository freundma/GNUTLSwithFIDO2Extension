[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/330/badge)](https://bestpractices.coreinfrastructure.org/projects/330)

|Branch|CI system|Status|Test suite coverage|Fuzzer coverage|
|:----:|:-------:|-----:|:------:|:-------------:|
|Master/3.6.x|Gitlab|[![build status](https://gitlab.com/gnutls/gnutls/badges/master/pipeline.svg)](https://gitlab.com/gnutls/gnutls/commits/master)|[![coverage report](https://gitlab.com/gnutls/gnutls/badges/master/coverage.svg)](https://gnutls.gitlab.io/coverage/master)|[![Fuzzer coverage report](https://gnutls.gitlab.io/coverage/master-fuzz/badge.svg)](https://gnutls.gitlab.io/coverage/master-fuzz)|
|Master/3.6.x|Travis|[![build status](https://travis-ci.org/gnutls/gnutls.svg?branch=master)](https://travis-ci.org/gnutls/gnutls)|N/A|N/A|


# GnuTLS with FIDO2 extension -- Information for developers

GnuTLS implements the TLS/SSL (Transport Layer Security aka Secure
Sockets Layer) protocol.  Additional information can be found at
[www.gnutls.org](https://www.gnutls.org/).

In the extension of GnuTLS the authentication via FIDO2 has been added as a proof of concept in the context of 
a bachelor thesis. The purpose of this is to make FIDO2 available for more internet users and help solving the
problem of the rather unsafe password authentication. The extension adds a new client hello extension,
four new message types and three new alerts. As there are two major ways of registering, a resident PKCS and
a non resident PKCS, the new TFE (TLS 1.3 with FIDO2 extension)-Handshake is offered in two modes. Please note
that the FIDO2 extension is only available for TLS 1.3 and the registration is not part of this yet.

# FI mode

In the FI mode a resident PKCS is assumed. The client hello extension contains a flag that indicates the FI mode in this case.
In the same RTT of the Server Hello and other messages the server sends the FIDO2 Assertion Request independet of the user which contains the 
PublicKeyRequestOptions including a cryptographic challenge (see WebAuthn specs for detail).
The FIDO2 Assertion Response of the client contains the signature generated by the FIDO token and other information 
to identify the user (again see WebAuthn spec). It is sent right before the Finish message.
After the server has verified the signature and the various other parameters, the client can be considered as authenticated
and data can be exchanged via the record protocol.

# FN mode

If the user is registered with a non resident PKCS the server needs to know the username in order to send the client
a list of allow credentials (ID of the PKCS to use). Therefore a doubled handshake is performed to confidentially send the username first and
then proceed with the actual authentication in the second handshake.
In the first handshake the client sends the FIDO2 client hello extension to indicate the purpose of authenticating himself via FIDO2.
A flag indicates the FN mode. Instead of a FIDO2 Assertion Request the sever sends a FIDO2 Name Request containing 32 random bytes.
The client does the same and generates 32 random bytes. Then the client calculates a SHA256-Hash over the concatenation of both and
saves the resulting ephemeral username. After that in the FIDO2 Name Response (right before the Finish) the client sends back
the 32 random bytes and the actual username. The server also calculates the SHA256-Hash over the concatenation of both and saves a tripel of
(ephemeral username, username, expiration time).
The TPC connection must be terminated after this and a new handshake is performed. This time the FIDO2 client hello extension contains the ephemeral username
and the flag for FN mode. Analogous to the TFE-FI-handshake the FIDO2 Assertion Request and the FIDO2 Assertion Reponse get exchanged with the FIDO2 Assertion Request containing the list of allow credentials determined by the username which is gathered by the ephemeral username.
Client and server can also negotiate a new ephemeral username for the next connection so only the second handshake needs to be executed.

# Registration

Although the registration is not part of this repository, the [java-webauthn-server](https://github.com/Yubico/java-webauthn-server) by Yubico is used to registrate a user.
The configuration of the TLS server offers the parameters to provide ip address and port of the java-webauthn-server. That means that the TLS server 
and java-webauthn-server work as one unit. Mind that the java-webauthn-server is in-memory. Your registration is volatile.

# Usage and addtitional information

This extension of FIDO2 uses the specification by Tom Breitopf who did a PoC within tlslite-ng. It is found [here](https://github.com/tom95br/tlslite-ng). 
The requirements to execute the code are found below.

The documentation of the api regarding FIDO2 is found under /doc/functions and examples for the usage under /doc/examples/ex-serv-fido2.c and 
doc/examples/ex-client-fido2.c. In order to run it you have to start the java-webauthn-server and registrate the user (for example in your browser). You can set
the allowed origins via an environment variable (which can be mandatory). Example:

```
 export YUBICO_WEBAUTHN_ALLOWED_ORIGINS="https://localhost:8443,https://localhost"
```

The server uses a SQLite3-database for saving the triples (ephemeral username, username, expiration time). You can execute the program 
/doc/examples/fido2-user-db.c to generate a suitable database.

# Licensing

The extension with FIDO2 is licensed under a GPLv3 license. See LICENSE and /doc/COPYING, /doc/COPYING.LESSER and /doc/COPYING.FIDO2 for more information.

# Requirements and installation

This file contains instructions for developers and advanced users that
want to build from version controlled sources. See [INSTALL.md](INSTALL.md)
for building released versions.

We require several tools to check out and build the software, including:

* [Make](https://www.gnu.org/software/make/)
* [Automake](https://www.gnu.org/software/automake/) (use 1.11.3 or later)
* [Autoconf](https://www.gnu.org/software/autoconf/)
* [Autogen](https://www.gnu.org/software/autogen/) (use 5.16 or later)
* [Libtool](https://www.gnu.org/software/libtool/)
* [Gettext](https://www.gnu.org/software/gettext/)
* [Texinfo](https://www.gnu.org/software/texinfo/)
* [Tar](https://www.gnu.org/software/tar/)
* [Gzip](https://www.gnu.org/software/gzip/)
* [Texlive & epsf](https://www.tug.org/texlive/) (for PDF manual)
* [GTK-DOC](https://www.gtk.org/gtk-doc/) (for API manual)
* [Git](https://git-scm.com/)
* [Perl](https://www.cpan.org/)
* [Nettle](https://www.lysator.liu.se/~nisse/nettle/)
* [Guile](https://www.gnu.org/software/guile/)
* [p11-kit](https://p11-glue.github.io/p11-glue/p11-kit.html)
* [gperf](https://www.gnu.org/software/gperf/)
* [libtasn1](https://www.gnu.org/software/libtasn1/) (optional)
* [Libidn2](https://www.gnu.org/software/libidn/#libidn2) (optional, for internationalization of DNS, IDNA 2008)
* [Libunistring](https://www.gnu.org/software/libunistring/) (optional, for internationalization)
* [AWK](https://www.gnu.org/software/awk/) (for make dist, pmccabe2html)
* [bison](https://www.gnu.org/software/bison) (for datetime parser in certtool)
* [libunbound](https://unbound.net/) (for DANE support)
* [libabigail](https://pagure.io/libabigail/) (for abi comparison in make dist)
* [tcsd](https://trousers.sourceforge.net/) (for TPM support; optional)
* [swtpm](https://github.com/stefanberger/swtpm) (for TPM test; optional)
* [ncat](https://nmap.org/download.html) (for TPM test; optional)
* [tpm-tools](https://trousers.sourceforge.net/) (for TPM test; optional)
* [expect](https://core.tcl.tk/expect/index) (for TPM test; optional)

Additional requirements for the FIDO2 extension:
* [java-webauthn-server](https://github.com/Yubico/java-webauthn-server)
* [libfido2](https://github.com/Yubico/libfido2) version 1.3.1 (later versions should also work)
* [Jansson](https://digip.org/jansson/) version 2.31 (later versions should also work)
* [SQLite3](https://sqlite.org/index.html) version 3.11.0 or later
* [liburl](https://curl.se/libcurl/)

The required software is typically distributed with your operating
system, and the instructions for installing them differ.  Here are
some hints:

Debian/Ubuntu:
```
apt-get install -y dash git-core autoconf libtool gettext autopoint
apt-get install -y automake autogen nettle-dev libp11-kit-dev libtspi-dev libunistring-dev
apt-get install -y guile-2.2-dev libtasn1-6-dev libidn2-0-dev gawk gperf
apt-get install -y libunbound-dev dns-root-data bison gtk-doc-tools
apt-get install -y texinfo texlive texlive-generic-recommended texlive-extra-utils
```

__NOTE:__ Some software versions might not be available in older releases, e.g. `nettle-dev`. 
Available backport repos, APT-Pinning or source code compilating can be used to install these versions (and dependencies) from a newer release.

Fedora/RHEL:
```
yum install -y dash git autoconf libtool gettext-devel automake autogen patch
yum install -y nettle-devel p11-kit-devel autogen-libopts-devel libunistring-devel
yum install -y trousers-devel guile22-devel libtasn1-devel libidn2-devel gawk gperf
yum install -y libtasn1-tools unbound-devel bison gtk-doc texinfo texlive
```

Sometimes, you may need to install more recent versions of Automake,
Nettle, P11-kit and Autogen, which you will need to build from sources. 

Dependencies that are used during make check or make dist are listed below.
Moreover, for basic interoperability testing you may want to install openssl
and mbedtls.

* [Valgrind](https://valgrind.org/) (optional)
* [Libasan](https://gcc.gnu.org//) (optional)
* [datefudge](https://packages.debian.org/datefudge) (optional)
* [nodejs](https://nodejs.org/) (needed for certain test cases)
* [softhsm](https://www.opendnssec.org/softhsm/) (for testing smart card support)
* [dieharder](https://www.phy.duke.edu/~rgb/General/dieharder.php) (for testing PRNG)
* [lcov](https://linux-test-project.github.io/) (for code coverage)
* [util-linux](https://github.com/karelzak/util-linux) or just [lscpu](https://github.com/NanXiao/lscpu) (for CPU feature detection)
* [libev](hhttp://software.schmorp.de/pkg/libev.html) (for testing)

Debian/Ubuntu:
```
apt-get install -y valgrind nodejs softhsm2 datefudge lcov libssl-dev libcmocka-dev expect libev-dev
apt-get install -y dieharder openssl abigail-tools socat net-tools ppp lockfile-progs util-linux
```

__NOTE:__ `libubsan0` and `libasan1` are required on older versions of Ubuntu <= 16.04. This packages must be manually added on these versions:

```
apt-get install -y v libubsan0 libasan1
```

Fedora/RHEL:
```
yum install -y valgrind libasan libasan-static libubsan nodejs softhsm datefudge lcov openssl-devel expect libev-devel
yum install -y dieharder mbedtls-utils openssl libabigail libcmocka-devel socat lockfile-progs util-linux
```


To download the version controlled sources:

```
$ git clone https://gitlab.com/gnutls/gnutls.git
$ cd gnutls
```

The next step is to bootstrap and ./configure:

```
$ ./bootstrap
$ ./configure
```

When built this way, some developer defaults will be enabled.  See
cfg.mk for details.

Then build the project normally, and run the test suite.

```
$ make
$ make check
```

To test the code coverage of the test suite use the following:
```
$ ./configure --enable-code-coverage
$ make && make check && make code-coverage-capture
```

Individual tests that may require additional hardware (e.g., smart cards)
are:
```
$ sh tests/suite/testpkcs11
```

# Building for windows

It is recommended to cross compile using Fedora and the following
dependencies:

```
yum install -y wine mingw32-nettle mingw32-libtasn1 mingw32-gcc
```

and build as:

```
mingw32-configure --enable-local-libopts --disable-non-suiteb-curves --disable-doc --without-p11-kit
mingw32-make
mingw32-make check
```

# Continuous Integration (CI)

We utilize two continuous integration systems, the gitlab-ci and travis.
Gitlab-CI is used to test most of the Linux systems (see .gitlab-ci.yml),
and is split in two phases, build image creation and compilation/test. The
build image creation is done at the gnutls/build-images subproject and
uploads the image at the gitlab.com container registry. The compilation/test
phase is on every commit to gnutls project.

The Travis based CI, is used to test compilation on MacOSX based systems.


# Contributing

See [the contributing document](CONTRIBUTING.md).


Happy hacking!

----------------------------------------------------------------------
Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.
